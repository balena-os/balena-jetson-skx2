From 9d4a851db73161f8cc6a1c1add36a762eeee01b4 Mon Sep 17 00:00:00 2001
From: Jason Allum <jason@slyce.it>
Date: Thu, 9 May 2019 15:10:44 +0000
Subject: [PATCH] Added the IMX219 and J20 drivers:

    Bumped copyright date.
    Added checks for dvdd-reg
    More tweaks
    Removed J20 #ifdefs
    Moved code back inside the J20 #ifndef
    Cleaned up.
    BuildFix: Didn't compile correctly without J20 driver.
    Updated Sony IMX219 driver for the Raspberry PI 2.1 camera.
    Added Auvidea J20 driver.
---
 drivers/media/i2c/Kconfig            |    9 +
 drivers/media/i2c/Makefile           |    1 +
 drivers/media/i2c/imx219.c           | 1432 +++++++++++++++++++---------------
 drivers/media/i2c/imx219_mode_tbls.h |  609 +++++++--------
 drivers/media/i2c/j20.c              |  109 +++
 5 files changed, 1190 insertions(+), 970 deletions(-)
 create mode 100644 drivers/media/i2c/j20.c

diff --git a/drivers/media/i2c/Kconfig b/drivers/media/i2c/Kconfig
index f94dfed..73273f1 100644
--- a/drivers/media/i2c/Kconfig
+++ b/drivers/media/i2c/Kconfig
@@ -817,6 +817,15 @@ config I2C_IOEXPANDER_PCA9570
 	  To compile this driver as a module, choose M here: the module
 	  will be called pca9570.
 
+config I2C_IOEXPANDER_J20
+	tristate "Auvidea J20 I2C IO Expander"
+	help
+	  If you say yes here you get support for the Auvidea J20 
+	  I2C IO Expander devices.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called j20.
+
 endmenu
 
 menu "Sensors used on soc_camera driver"
diff --git a/drivers/media/i2c/Makefile b/drivers/media/i2c/Makefile
index 5f3a2fa..4a9763d 100644
--- a/drivers/media/i2c/Makefile
+++ b/drivers/media/i2c/Makefile
@@ -88,6 +88,7 @@ obj-$(CONFIG_VIDEO_OV10823) += ov10823.o
 obj-$(CONFIG_VIDEO_OV23850) += ov23850.o
 obj-$(CONFIG_VIDEO_LC898212) += lc898212.o
 obj-$(CONFIG_VIDEO_OV5693) += ov5693.o
+obj-$(CONFIG_I2C_IOEXPANDER_J20) += j20.o
 obj-$(CONFIG_VIDEO_IMX219) += imx219.o
 obj-$(CONFIG_VIDEO_IMX274) += imx274.o
 obj-$(CONFIG_VIDEO_TC358840)	+= tc358840.o
diff --git a/drivers/media/i2c/imx219.c b/drivers/media/i2c/imx219.c
index 64d6e04..fe0db69 100644
--- a/drivers/media/i2c/imx219.c
+++ b/drivers/media/i2c/imx219.c
@@ -16,7 +16,6 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#include <dt-bindings/gpio/tegra-gpio.h>
 #include <linux/slab.h>
 #include <linux/uaccess.h>
 #include <linux/gpio.h>
@@ -27,316 +26,440 @@
 #include <linux/of_device.h>
 #include <linux/of_gpio.h>
 
-#include <media/tegra-v4l2-camera.h>
 #include <media/camera_common.h>
-#include <media/soc_camera.h>
 #include <media/imx219.h>
 
+#include "../platform/tegra/camera/camera_gpio.h"
+
 #include "imx219_mode_tbls.h"
 
-#define IMX219_MAX_COARSE_DIFF		4
+#define IMX219_MAX_COARSE_DIFF    4
+
+#define IMX219_GAIN_SHIFT         (8)
+#define IMX219_MIN_GAIN                  (1 << IMX219_GAIN_SHIFT)
+#define IMX219_MAX_GAIN                  (16 << IMX219_GAIN_SHIFT)
 
-#define IMX219_GAIN_SHIFT		8
-#define IMX219_MIN_GAIN		(1 << IMX219_GAIN_SHIFT)
-#define IMX219_MAX_GAIN		(16 << IMX219_GAIN_SHIFT)
-#define IMX219_MIN_FRAME_LENGTH	(0x9C3)
-#define IMX219_MAX_FRAME_LENGTH	(0xFFFF)
-#define IMX219_MIN_EXPOSURE_COARSE	(0x0001)
-#define IMX219_MAX_EXPOSURE_COARSE	\
-	(IMX219_MAX_FRAME_LENGTH-IMX219_MAX_COARSE_DIFF)
+#define IMX219_MIN_FRAME_LENGTH   (0x0)
+#define IMX219_MAX_FRAME_LENGTH   (0x7FFF)
+#define IMX219_MIN_EXPOSURE_COARSE      (0x0001)
+#define IMX219_MAX_EXPOSURE_COARSE  \
+  (IMX219_MAX_FRAME_LENGTH-IMX219_MAX_COARSE_DIFF)
 
-#define IMX219_DEFAULT_GAIN		IMX219_MIN_GAIN
-#define IMX219_DEFAULT_FRAME_LENGTH	(0x09C3)
-#define IMX219_DEFAULT_EXPOSURE_COARSE	\
-	(IMX219_DEFAULT_FRAME_LENGTH-IMX219_MAX_COARSE_DIFF)
+#define IMX219_DEFAULT_GAIN       (IMX219_MIN_GAIN)
+#define IMX219_DEFAULT_FRAME_LENGTH     (1766)
+#define IMX219_DEFAULT_EXPOSURE_COARSE  \
+  (IMX219_DEFAULT_FRAME_LENGTH-IMX219_MAX_COARSE_DIFF)
 
-#define IMX219_DEFAULT_MODE	IMX219_MODE_3280x2464
-#define IMX219_DEFAULT_WIDTH	3280
-#define IMX219_DEFAULT_HEIGHT	2464
-#define IMX219_DEFAULT_DATAFMT	MEDIA_BUS_FMT_SRGGB10_1X10
-#define IMX219_DEFAULT_CLK_FREQ	12000000
+#define IMX219_DEFAULT_MODE IMX219_MODE_1920X1080
+#define IMX219_DEFAULT_WIDTH  1920
+#define IMX219_DEFAULT_HEIGHT       1080
+#define IMX219_DEFAULT_DATAFMT      MEDIA_BUS_FMT_SRGGB10_1X10
+#define IMX219_DEFAULT_CLK_FREQ     24000000
 
 struct imx219 {
-	struct camera_common_power_rail	power;
-	int				num_ctrls;
-	struct v4l2_ctrl_handler	ctrl_handler;
-	struct i2c_client		*i2c_client;
-	struct v4l2_subdev		*subdev;
-	struct media_pad		pad;
-	struct regmap			*regmap;
-	struct camera_common_data	*s_data;
-	struct camera_common_pdata	*pdata;
-	struct v4l2_ctrl		*ctrls[];
+  struct camera_common_power_rail power;
+  int       numctrls;
+  struct v4l2_ctrl_handler  ctrl_handler;
+  struct i2c_client   *i2c_client;
+  struct v4l2_subdev    *subdev;
+  struct media_pad    pad;
+  struct regmap     *regmap;
+  struct camera_common_data *s_data;
+  struct camera_common_pdata  *pdata;
+  struct v4l2_ctrl    *ctrls[];
 };
 
-static const struct regmap_config sensor_regmap_config = {
-	.reg_bits = 16,
-	.val_bits = 8,
-	.cache_type = REGCACHE_RBTREE,
+static const struct regmap_config imx219_regmap_config = {
+  .reg_bits = 16,
+  .val_bits = 8,
+  .cache_type = REGCACHE_RBTREE,
 };
 
 static int imx219_g_volatile_ctrl(struct v4l2_ctrl *ctrl);
 static int imx219_s_ctrl(struct v4l2_ctrl *ctrl);
 
 static const struct v4l2_ctrl_ops imx219_ctrl_ops = {
-	.g_volatile_ctrl = imx219_g_volatile_ctrl,
-	.s_ctrl	= imx219_s_ctrl,
+  .g_volatile_ctrl  = imx219_g_volatile_ctrl,
+  .s_ctrl     = imx219_s_ctrl,
 };
 
 static struct v4l2_ctrl_config ctrl_config_list[] = {
 /* Do not change the name field for the controls! */
-	{
-		.ops = &imx219_ctrl_ops,
-		.id = TEGRA_CAMERA_CID_GAIN,
-		.name = "Gain",
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.flags = V4L2_CTRL_FLAG_SLIDER,
-		.min = IMX219_MIN_GAIN,
-		.max = IMX219_MAX_GAIN,
-		.def = IMX219_DEFAULT_GAIN,
-		.step = 1,
-	},
-	{
-		.ops = &imx219_ctrl_ops,
-		.id = TEGRA_CAMERA_CID_FRAME_LENGTH,
-		.name = "Frame Length",
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.flags = V4L2_CTRL_FLAG_SLIDER,
-		.min = IMX219_MIN_FRAME_LENGTH,
-		.max = IMX219_MAX_FRAME_LENGTH,
-		.def = IMX219_DEFAULT_FRAME_LENGTH,
-		.step = 1,
-	},
-	{
-		.ops = &imx219_ctrl_ops,
-		.id = TEGRA_CAMERA_CID_COARSE_TIME,
-		.name = "Coarse Time",
-		.type = V4L2_CTRL_TYPE_INTEGER,
-		.flags = V4L2_CTRL_FLAG_SLIDER,
-		.min = IMX219_MIN_EXPOSURE_COARSE,
-		.max = IMX219_MAX_EXPOSURE_COARSE,
-		.def = IMX219_DEFAULT_EXPOSURE_COARSE,
-		.step = 1,
-	},
-	{
-		.ops = &imx219_ctrl_ops,
-		.id = TEGRA_CAMERA_CID_GROUP_HOLD,
-		.name = "Group Hold",
-		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
-		.min = 0,
-		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
-		.menu_skip_mask = 0,
-		.def = 0,
-		.qmenu_int = switch_ctrl_qmenu,
-	},
-	{
-		.ops = &imx219_ctrl_ops,
-		.id = TEGRA_CAMERA_CID_HDR_EN,
-		.name = "HDR enable",
-		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
-		.min = 0,
-		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
-		.menu_skip_mask = 0,
-		.def = 0,
-		.qmenu_int = switch_ctrl_qmenu,
-	},
-	{
-		.ops = &imx219_ctrl_ops,
-		.id = TEGRA_CAMERA_CID_FUSE_ID,
-		.name = "Fuse ID",
-		.type = V4L2_CTRL_TYPE_STRING,
-		.flags = V4L2_CTRL_FLAG_READ_ONLY,
-		.min = 0,
-		.max = IMX219_FUSE_ID_STR_SIZE,
-		.step = 2,
-	},
+  {
+    .ops = &imx219_ctrl_ops,
+    .id = TEGRA_CAMERA_CID_GAIN,
+    .name = "Gain",
+    .type = V4L2_CTRL_TYPE_INTEGER,
+    .flags = V4L2_CTRL_FLAG_SLIDER,
+    .min = IMX219_MIN_GAIN,
+    .max = IMX219_MAX_GAIN,
+    .def = IMX219_DEFAULT_GAIN,
+    .step = 1,
+  },
+  {
+    .ops = &imx219_ctrl_ops,
+    .id = TEGRA_CAMERA_CID_FRAME_LENGTH,
+    .name = "Frame Length",
+    .type = V4L2_CTRL_TYPE_INTEGER,
+    .flags = V4L2_CTRL_FLAG_SLIDER,
+    .min = IMX219_MIN_FRAME_LENGTH,
+    .max = IMX219_MAX_FRAME_LENGTH,
+    .def = IMX219_DEFAULT_FRAME_LENGTH,
+    .step = 1,
+  },
+  {
+    .ops = &imx219_ctrl_ops,
+    .id = TEGRA_CAMERA_CID_COARSE_TIME,
+    .name = "Coarse Time",
+    .type = V4L2_CTRL_TYPE_INTEGER,
+    .flags = V4L2_CTRL_FLAG_SLIDER,
+    .min = IMX219_MIN_EXPOSURE_COARSE,
+    .max = IMX219_MAX_EXPOSURE_COARSE,
+    .def = IMX219_DEFAULT_EXPOSURE_COARSE,
+    .step = 1,
+  },
+  {
+    .ops = &imx219_ctrl_ops,
+    .id = TEGRA_CAMERA_CID_GROUP_HOLD,
+    .name = "Group Hold",
+    .type = V4L2_CTRL_TYPE_INTEGER_MENU,
+    .min = 0,
+    .max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+    .menu_skip_mask = 0,
+    .def = 0,
+    .qmenu_int = switch_ctrl_qmenu,
+  },
+  {
+    .ops = &imx219_ctrl_ops,
+    .id = TEGRA_CAMERA_CID_HDR_EN,
+    .name = "HDR enable",
+    .type = V4L2_CTRL_TYPE_INTEGER_MENU,
+    .min = 0,
+    .max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+    .menu_skip_mask = 0,
+    .def = 0,
+    .qmenu_int = switch_ctrl_qmenu,
+  },
+  {
+    .ops = &imx219_ctrl_ops,
+    .id = TEGRA_CAMERA_CID_FUSE_ID,
+    .name = "Fuse ID",
+    .type = V4L2_CTRL_TYPE_STRING,
+    .flags = V4L2_CTRL_FLAG_READ_ONLY,
+    .min = 0,
+    .max = IMX219_FUSE_ID_STR_SIZE,
+    .step = 2,
+  },
 };
 
-static inline void imx219_get_gain_reg(struct reg_8 *regs,
-				u8 gain)
+static inline void imx219_get_frame_length_regs(struct reg_8 *regs, u16 frame_length)
+{
+  regs->addr = IMX219_FRAME_LENGTH_ADDR_MSB;
+  regs->val = (frame_length >> 8) & 0xff;
+  (regs + 1)->addr = IMX219_FRAME_LENGTH_ADDR_LSB;
+  (regs + 1)->val = (frame_length) & 0xff;
+}
+
+static inline void imx219_get_coarse_time_regs(struct reg_8 *regs, u16 coarse_time)
+{
+  regs->addr = IMX219_COARSE_TIME_ADDR_MSB;
+  regs->val = (coarse_time >> 8) & 0xff;
+  (regs + 1)->addr = IMX219_COARSE_TIME_ADDR_LSB;
+  (regs + 1)->val = (coarse_time) & 0xff;
+}
+
+static inline void imx219_get_gain_reg(struct reg_8 *regs, u8 gain)
 {
-	regs->addr = IMX219_GAIN_ADDR;
-	regs->val = gain & 0xff;
+  regs->addr = IMX219_GAIN_ADDR;
+  regs->val = gain & 0xff;
 }
 
 static int test_mode;
 module_param(test_mode, int, 0644);
 
-static inline int imx219_read_reg(struct camera_common_data *s_data,
-				u16 addr, u8 *val)
+static inline int imx219_read_reg(struct camera_common_data *s_data, u16 addr, u8 *val)
 {
-	struct imx219 *priv = (struct imx219 *)s_data->priv;
-	return regmap_read(priv->regmap, addr, (unsigned int *) val);
+  struct imx219 *priv = (struct imx219 *)s_data->priv;
+  int err = 0;
+  u32 reg_val = 0;
+
+  err = regmap_read(priv->regmap, addr, &reg_val);
+  *val = reg_val & 0xFF;
+
+  return err;
 }
 
 static int imx219_write_reg(struct camera_common_data *s_data, u16 addr, u8 val)
 {
-	int err;
-	struct imx219 *priv = (struct imx219 *)s_data->priv;
+  int err;
+  struct imx219 *priv = (struct imx219 *)s_data->priv;
 
-	err = regmap_write(priv->regmap, addr, val);
-	if (err)
-		pr_err("%s:i2c write failed, %x = %x\n",
-			__func__, addr, val);
+  err = regmap_write(priv->regmap, addr, val);
+  if (err)
+    pr_err("%s:i2c write failed, %x = %x\n",
+      __func__, addr, val);
 
-	return err;
+  return err;
 }
 
-static int imx219_write_table(struct imx219 *priv,
-			      const struct reg_8 table[])
+static int imx219_write_table(struct imx219 *priv, const struct reg_8 table[])
 {
-	return regmap_util_write_table_8(priv->regmap,
-					 table,
-					 NULL, 0,
-					 IMX219_TABLE_WAIT_MS,
-					 IMX219_TABLE_END);
+  return regmap_util_write_table_8(priv->regmap,
+     table,
+     NULL, 0,
+     IMX219_TABLE_WAIT_MS,
+     IMX219_TABLE_END);
 }
 
 static void imx219_mclk_disable(struct camera_common_power_rail *pw)
 {
-	clk_disable_unprepare(pw->mclk);
+  clk_disable_unprepare(pw->mclk);
 }
 
 static void imx219_mclk_enable(struct camera_common_power_rail *pw)
 {
-	clk_set_rate(pw->mclk, IMX219_DEFAULT_CLK_FREQ);
-	clk_prepare_enable(pw->mclk);
+  clk_set_rate(pw->mclk, IMX219_DEFAULT_CLK_FREQ);
+  clk_prepare_enable(pw->mclk);
 }
 
-static int imx219_power_on(struct camera_common_data *s_data)
+static void imx219_gpio_set(struct imx219 *priv,
+          unsigned int gpio, int val)
 {
-	int err = 0;
-	struct imx219 *priv = (struct imx219 *)s_data->priv;
-	struct camera_common_power_rail *pw = &priv->power;
-
-	dev_dbg(&priv->i2c_client->dev, "%s: power on\n", __func__);
-
-	if (gpio_cansleep(pw->reset_gpio))
-		gpio_set_value_cansleep(pw->reset_gpio, 0);
-	else
-		gpio_set_value(pw->reset_gpio, 0);
-	usleep_range(10, 20);
-
-	if (pw->avdd)
-		err = regulator_enable(pw->avdd);
-	if (err)
-		goto imx219_avdd_fail;
+  if (priv->pdata && priv->pdata->use_cam_gpio)
+    cam_gpio_ctrl(&priv->i2c_client->dev, gpio, val, 1);
+  else {
+    if (gpio_cansleep(gpio))
+      gpio_set_value_cansleep(gpio, val);
+    else
+      gpio_set_value(gpio, val);
+  }
+}
 
-	if (pw->iovdd)
-		err = regulator_enable(pw->iovdd);
-	if (err)
-		goto imx219_iovdd_fail;
+static int imx219_power_on(struct camera_common_data *s_data)
+{
+  int err = 0;
+  struct imx219 *priv = (struct imx219 *)s_data->priv;
+  struct camera_common_power_rail *pw = &priv->power;
+
+  dev_info(&priv->i2c_client->dev, "%s: power on\n", __func__);
+
+  if (pw->reset_gpio) {
+    imx219_gpio_set(priv, pw->reset_gpio, 0);
+  }
+#if 0
+  if (pw->pwdn_gpio) {
+    imx219_gpio_set(priv, pw->pwdn_gpio, 0);
+  }
+#endif
 
-	if (pw->dvdd)
-		err = regulator_enable(pw->dvdd);
-	if (err)
-		goto imx219_dvdd_fail;
+  usleep_range(10, 20);
+
+  if (pw->avdd)
+    err = regulator_enable(pw->avdd);
+  if (err)
+    goto imx219_avdd_fail;
+  if (pw->iovdd)
+    err = regulator_enable(pw->iovdd);
+  if (err)
+    goto imx219_iovdd_fail;
+  if (pw->dvdd)
+    err = regulator_enable(pw->dvdd);
+  if (err)
+    goto imx219_dvdd_fail;
+
+  usleep_range(10, 20);
+
+#if 0
+  if (pw->pwdn_gpio) {
+    imx219_gpio_set(priv, pw->pwdn_gpio, 1);
+  }
+#endif
+  if (pw->reset_gpio) {
+    imx219_gpio_set(priv, pw->reset_gpio, 1);
+  }
 
-	usleep_range(1, 2);
-	if (gpio_cansleep(pw->reset_gpio))
-		gpio_set_value_cansleep(pw->reset_gpio, 1);
-	else
-		gpio_set_value(pw->reset_gpio, 1);
+  usleep_range(10, 20);
 
-	usleep_range(1, 2);
-	imx219_mclk_enable(pw);
+  imx219_mclk_enable(pw);
 
-	/* Need to wait for t4 + t5 + t9 time as per the data sheet */
-	/* t4 - 200us, t5 - 6ms, t9 - 1.2ms */
-	usleep_range(7400, 7410);
+  /* Need to wait for t4 + t5 + t9 time as per the data sheet */
+  /* t4 - 200us, t5 - 6ms, t9 - 1.2ms */
+  usleep_range(7400, 7410);
 
-	pw->state = SWITCH_ON;
-	return 0;
+  pw->state = SWITCH_ON;
+  return 0;
 
 imx219_dvdd_fail:
-	regulator_disable(pw->iovdd);
-
+  regulator_disable(pw->iovdd);
 imx219_iovdd_fail:
-	regulator_disable(pw->avdd);
-
+  regulator_disable(pw->avdd);
 imx219_avdd_fail:
-	return -ENODEV;
+  return -ENODEV;
 }
 
 static int imx219_power_off(struct camera_common_data *s_data)
 {
-	struct imx219 *priv = (struct imx219 *)s_data->priv;
-	struct camera_common_power_rail *pw = &priv->power;
-
-	dev_dbg(&priv->i2c_client->dev, "%s: power off\n", __func__);
-
-	usleep_range(1, 2);
-	if (gpio_cansleep(pw->reset_gpio))
-		gpio_set_value_cansleep(pw->reset_gpio, 0);
-	else
-		gpio_set_value(pw->reset_gpio, 0);
-	usleep_range(1, 2);
-
-	if (pw->dvdd)
-		regulator_disable(pw->dvdd);
-	if (pw->iovdd)
-		regulator_disable(pw->iovdd);
-	if (pw->avdd)
-		regulator_disable(pw->avdd);
-
-	imx219_mclk_disable(pw);
-	pw->state = SWITCH_OFF;
-	return 0;
-}
-
-static int imx219_power_put(struct imx219 *priv)
-{
-	struct camera_common_power_rail *pw = &priv->power;
-	if (unlikely(!pw))
-		return -EFAULT;
-
-	if (likely(pw->avdd))
-		regulator_put(pw->avdd);
+  struct imx219 *priv = (struct imx219 *)s_data->priv;
+  struct camera_common_power_rail *pw = &priv->power;
+
+  dev_info(&priv->i2c_client->dev, "%s: power off\n", __func__);
+
+  usleep_range(1, 2);
+  if (pw->reset_gpio) {
+    imx219_gpio_set(priv, pw->reset_gpio, 0);
+  }
+#if 0
+  if (pw->pwdn_gpio) {
+    imx219_gpio_set(priv, pw->pwdn_gpio, 0);
+  }
+#endif
+  usleep_range(1, 2);
 
-	if (likely(pw->iovdd))
-		regulator_put(pw->iovdd);
+  if (pw->dvdd)
+    regulator_disable(pw->dvdd);
+  if (pw->iovdd)
+    regulator_disable(pw->iovdd);
+  if (pw->avdd)
+    regulator_disable(pw->avdd);
 
-	if (likely(pw->dvdd))
-		regulator_put(pw->dvdd);
+  imx219_mclk_disable(pw);
 
-	pw->avdd = NULL;
-	pw->iovdd = NULL;
-	pw->dvdd = NULL;
+  pw->state = SWITCH_OFF;
+  return 0;
+}
 
-	return 0;
+static int imx219_power_put(struct imx219 *priv)
+{
+  struct camera_common_power_rail *pw = &priv->power;
+  if (unlikely(!pw))
+    return -EFAULT;
+
+  if (likely(pw->avdd))
+    regulator_put(pw->avdd);
+  if (likely(pw->iovdd))
+    regulator_put(pw->iovdd);
+  if (likely(pw->dvdd))
+    regulator_put(pw->dvdd);
+
+  pw->avdd = NULL;
+  pw->iovdd = NULL;
+  pw->dvdd = NULL;
+
+  if (priv->pdata && priv->pdata->use_cam_gpio) {
+    if (pw->pwdn_gpio) {
+      cam_gpio_deregister(&priv->i2c_client->dev, pw->pwdn_gpio);
+    }
+    if (pw->reset_gpio) {
+      cam_gpio_deregister(&priv->i2c_client->dev, pw->reset_gpio);
+    }
+  } else {
+    if (pw->pwdn_gpio) {
+      gpio_free(pw->pwdn_gpio);
+    }
+    if (pw->reset_gpio) {
+      gpio_free(pw->reset_gpio);
+    }
+  }
+
+  return 0;
 }
 
 static int imx219_power_get(struct imx219 *priv)
 {
-	struct camera_common_power_rail *pw = &priv->power;
-	struct camera_common_pdata *pdata = priv->pdata;
-	const char *mclk_name;
-	int err = 0;
-
-	mclk_name = priv->pdata->mclk_name ?
-		    priv->pdata->mclk_name : "cam_mclk1";
-	pw->mclk = devm_clk_get(&priv->i2c_client->dev, mclk_name);
-	if (IS_ERR(pw->mclk)) {
-		dev_err(&priv->i2c_client->dev,
-			"unable to get clock %s\n", mclk_name);
-		return PTR_ERR(pw->mclk);
-	}
-
-	/* ananlog 2.7v */
-	err |= camera_common_regulator_get(&priv->i2c_client->dev,
-			&pw->avdd, pdata->regulators.avdd);
-	/* digital 1.2v */
-	err |= camera_common_regulator_get(&priv->i2c_client->dev,
-			&pw->dvdd, pdata->regulators.dvdd);
-	/* IO 1.8v */
-	err |= camera_common_regulator_get(&priv->i2c_client->dev,
-			&pw->iovdd, pdata->regulators.iovdd);
-
-	if (!err)
-		pw->reset_gpio = pdata->reset_gpio;
-
-	pw->state = SWITCH_OFF;
-	return err;
+  struct camera_common_power_rail *pw = &priv->power;
+  struct camera_common_pdata *pdata = priv->pdata;
+  const char *mclk_name;
+  const char *parentclk_name;
+  struct clk *parent;
+  int err = 0;
+  int ret = 0;
+
+  if (!pdata) {
+    dev_err(&priv->i2c_client->dev, "pdata missing\n");
+    return -EFAULT;
+  }
+
+  mclk_name = pdata->mclk_name ?
+        pdata->mclk_name : "cam_mclk1";
+  pw->mclk = devm_clk_get(&priv->i2c_client->dev, mclk_name);
+  if (IS_ERR(pw->mclk)) {
+    dev_err(&priv->i2c_client->dev,
+      "unable to get clock %s\n", mclk_name);
+    return PTR_ERR(pw->mclk);
+  }
+
+  parentclk_name = pdata->parentclk_name;
+  if (parentclk_name) {
+    parent = devm_clk_get(&priv->i2c_client->dev, parentclk_name);
+    if (IS_ERR(parent)) {
+      dev_err(&priv->i2c_client->dev,
+        "unable to get parent clcok %s",
+        parentclk_name);
+    } else
+      clk_set_parent(pw->mclk, parent);
+  }
+
+  if (pdata->regulators.avdd) {
+    /* analog 2.8v */
+    err |= camera_common_regulator_get(&priv->i2c_client->dev,
+        &pw->avdd, pdata->regulators.avdd);
+  }
+  if (pdata->regulators.iovdd) {
+    /* IO 1.8v */
+    err |= camera_common_regulator_get(&priv->i2c_client->dev,
+        &pw->iovdd, pdata->regulators.iovdd);
+  }
+  if (pdata->regulators.dvdd) {
+    err |= camera_common_regulator_get(&priv->i2c_client->dev,
+        &pw->dvdd, pdata->regulators.dvdd);
+  }
+
+  if (!err) {
+    pw->reset_gpio = pdata->reset_gpio;
+    pw->pwdn_gpio = pdata->pwdn_gpio;
+  }
+
+  dev_info(&priv->i2c_client->dev, "%s: reset_gpio: %u\n", __func__, pdata->reset_gpio);
+  dev_info(&priv->i2c_client->dev, "%s: pwdn_gpio: %u\n", __func__, pdata->pwdn_gpio);
+
+  if (pdata->use_cam_gpio) {
+    if (pw->pwdn_gpio) {
+      err = cam_gpio_register(&priv->i2c_client->dev, pw->pwdn_gpio);
+      if (err)
+        dev_err(&priv->i2c_client->dev,
+          "%s ERR can't register cam pwdn_gpio %u!\n",
+           __func__, pw->pwdn_gpio);
+    }
+    if (pw->reset_gpio) {
+      err = cam_gpio_register(&priv->i2c_client->dev, pw->reset_gpio);
+      if (err)
+        dev_err(&priv->i2c_client->dev,
+          "%s ERR can't register cam reset_gpio %u!\n",
+           __func__, pw->reset_gpio);
+    }
+  } else {
+    if (pw->pwdn_gpio) {
+      ret = gpio_request(pw->pwdn_gpio, "cam_pwdn_gpio");
+      if (ret < 0)
+        dev_dbg(&priv->i2c_client->dev,
+          "%s can't request pwdn_gpio %d\n",
+          __func__, ret);
+    }
+    if (pw->reset_gpio) {
+      ret = gpio_request(pw->reset_gpio, "cam_reset_gpio");
+      if (ret < 0)
+        dev_dbg(&priv->i2c_client->dev,
+          "%s can't request reset_gpio %d\n",
+          __func__, ret);
+    }
+  }
+
+  if (pw->pwdn_gpio) {
+    imx219_gpio_set(priv, pw->pwdn_gpio, 1);
+  }
+
+  pw->state = SWITCH_OFF;
+  return err;
 }
 
 static int imx219_set_gain(struct imx219 *priv, s32 val);
@@ -345,525 +468,583 @@ static int imx219_set_coarse_time(struct imx219 *priv, s32 val);
 
 static int imx219_s_stream(struct v4l2_subdev *sd, int enable)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
-	struct imx219 *priv = (struct imx219 *)s_data->priv;
-	int err;
-
-	dev_dbg(&client->dev, "%s\n", __func__);
-
-	if (!enable)
-		return 0;
-
-	err = imx219_write_table(priv, mode_table[s_data->mode]);
-	if (err)
-		goto exit;
-
-	return 0;
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+  struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+  struct imx219 *priv = (struct imx219 *)s_data->priv;
+  struct v4l2_control control;
+  int err;
+
+  dev_info(&client->dev, "%s\n", __func__);
+
+  if (!enable) {
+    dev_info(&client->dev, "%s: Stopping Stream\n", __func__);
+    return imx219_write_table(priv, mode_table[IMX219_MODE_STOP_STREAM]);
+  }
+
+  err = imx219_write_table(priv, mode_table[IMX219_MODE_COMMON]);
+  if (err) {
+    dev_err(&client->dev, "%s: Failed to set common values\n", __func__);
+    goto exit;
+  }
+  err = imx219_write_table(priv, mode_table[s_data->mode]);
+  dev_info(&client->dev, "%s: Setting mode: %d\n", __func__, s_data->mode);
+  if (err) {
+    dev_err(&client->dev, "%s: Error setting camera mode\n", __func__);
+    goto exit;
+  }
+  err = imx219_write_table(priv, mode_table[IMX219_MODE_CLOCK]);
+  if (err) {
+    dev_err(&client->dev, "%s: Failed to set clock values\n", __func__);
+    goto exit;
+  }
+
+  //Write all the overrides
+  //Gain
+  control.id = TEGRA_CAMERA_CID_GAIN;
+  err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+  err |= imx219_set_gain(priv, control.value);
+  if (err) {
+    dev_err(&client->dev, "%s: error gain override\n", __func__);
+  }
+
+  //Frame Length
+  control.id = TEGRA_CAMERA_CID_FRAME_LENGTH;
+  err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+  err |= imx219_set_frame_length(priv, control.value);
+  if (err) {
+    dev_err(&client->dev, "%s: error frame length override\n", __func__);
+  }
+
+  //Coarse Time (Exposure Length)
+  control.id = TEGRA_CAMERA_CID_COARSE_TIME;
+  err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+  err |= imx219_set_coarse_time(priv, control.value);
+  dev_info(&client->dev, "%s: Coarse Time: %d\n", __func__, control.value);
+  if (err) {
+    dev_err(&client->dev,
+      "%s: error coarse time override\n", __func__);
+  }
+
+  dev_info(&client->dev, "%s: Starting stream\n", __func__);
+  err = imx219_write_table(priv, mode_table[IMX219_MODE_START_STREAM]);
+  if (err)
+    goto exit;
+
+  return 0;
 exit:
-	dev_dbg(&client->dev, "%s: error setting stream\n", __func__);
-	return err;
+  dev_info(&client->dev, "%s: error setting stream\n", __func__);
+  return err;
 }
 
 static int imx219_g_input_status(struct v4l2_subdev *sd, u32 *status)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
-	struct imx219 *priv = (struct imx219 *)s_data->priv;
-	struct camera_common_power_rail *pw = &priv->power;
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+  struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+  struct imx219 *priv = (struct imx219 *)s_data->priv;
+  struct camera_common_power_rail *pw = &priv->power;
 
-	*status = pw->state == SWITCH_ON;
-	return 0;
+  *status = pw->state == SWITCH_ON;
+  return 0;
 }
 
+static struct v4l2_subdev_video_ops imx219_subdev_video_ops = {
+  .s_stream = imx219_s_stream,
+  .g_mbus_config  = camera_common_g_mbus_config,
+
+  .g_input_status = imx219_g_input_status,
+};
+static struct v4l2_subdev_core_ops imx219_subdev_core_ops = {
+  .s_power  = camera_common_s_power,
+};
+
 static int imx219_get_fmt(struct v4l2_subdev *sd,
-		struct v4l2_subdev_pad_config *cfg,
-		struct v4l2_subdev_format *format)
+    struct v4l2_subdev_pad_config *cfg,
+    struct v4l2_subdev_format *format)
 {
-	return camera_common_g_fmt(sd, &format->format);
+  return camera_common_g_fmt(sd, &format->format);
 }
 
 static int imx219_set_fmt(struct v4l2_subdev *sd,
-		struct v4l2_subdev_pad_config *cfg,
-		struct v4l2_subdev_format *format)
+    struct v4l2_subdev_pad_config *cfg,
+  struct v4l2_subdev_format *format)
 {
-	int ret;
+  int ret;
 
-	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
-		ret = camera_common_try_fmt(sd, &format->format);
-	else
-		ret = camera_common_s_fmt(sd, &format->format);
+  if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+    ret = camera_common_try_fmt(sd, &format->format);
+  else
+    ret = camera_common_s_fmt(sd, &format->format);
 
-	return ret;
+  return ret;
 }
 
-static struct v4l2_subdev_video_ops imx219_subdev_video_ops = {
-	.s_stream	= imx219_s_stream,
-	.g_mbus_config	= camera_common_g_mbus_config,
-	.g_input_status	= imx219_g_input_status,
-};
-
-static struct v4l2_subdev_core_ops imx219_subdev_core_ops = {
-	.s_power	= camera_common_s_power,
-};
-
 static struct v4l2_subdev_pad_ops imx219_subdev_pad_ops = {
-	.enum_mbus_code = camera_common_enum_mbus_code,
-	.set_fmt = imx219_set_fmt,
-	.get_fmt = imx219_get_fmt,
-	.enum_frame_size	= camera_common_enum_framesizes,
-	.enum_frame_interval	= camera_common_enum_frameintervals,
+  .enum_mbus_code = camera_common_enum_mbus_code,
+  .set_fmt = imx219_set_fmt,
+  .get_fmt = imx219_get_fmt,
+  .enum_frame_size  = camera_common_enum_framesizes,
+  .enum_frame_interval  = camera_common_enum_frameintervals,
 };
 
 static struct v4l2_subdev_ops imx219_subdev_ops = {
-	.core	= &imx219_subdev_core_ops,
-	.video	= &imx219_subdev_video_ops,
-	.pad	= &imx219_subdev_pad_ops,
+  .core   = &imx219_subdev_core_ops,
+  .video  = &imx219_subdev_video_ops,
+  .pad    = &imx219_subdev_pad_ops,
 };
 
 static struct of_device_id imx219_of_match[] = {
-	{ .compatible = "nvidia,imx219", },
-	{ },
+  { .compatible = "nvidia,imx219", },
+  { },
 };
 
 static struct camera_common_sensor_ops imx219_common_ops = {
-	.power_on = imx219_power_on,
-	.power_off = imx219_power_off,
-	.write_reg = imx219_write_reg,
-	.read_reg = imx219_read_reg,
+  .power_on   = imx219_power_on,
+  .power_off  = imx219_power_off,
+  .write_reg  = imx219_write_reg,
+  .read_reg   = imx219_read_reg,
 };
 
 static int imx219_set_group_hold(struct imx219 *priv, s32 val)
 {
-	/* IMX219 does not support group hold */
-	return 0;
+  /* IMX219 does not support group hold */
+  return 0;
 }
 
 static int imx219_set_gain(struct imx219 *priv, s32 val)
 {
-	struct reg_8 reg;
-	int err;
-	u8 gain;
+  struct reg_8 reg;
+  int err;
+  u8 gain;
 
-	/* translate value */
-	gain = 256 - (256 * (1 << IMX219_GAIN_SHIFT) / val);
-	dev_dbg(&priv->i2c_client->dev,
-		 "%s: val: %d\n", __func__, gain);
+  /* translate value */
+  gain = 256 - (256 * (1 << IMX219_GAIN_SHIFT) / val);
+  dev_dbg(&priv->i2c_client->dev,
+     "%s: val: %d\n", __func__, gain);
 
-	imx219_get_gain_reg(&reg, gain);
+  imx219_get_gain_reg(&reg, gain);
 
-	err = imx219_write_reg(priv->s_data, reg.addr, reg.val);
-	if (err)
-		goto fail;
+  err = imx219_write_reg(priv->s_data, reg.addr, reg.val);
+  if (err)
+    goto fail;
 
-	return 0;
+  return 0;
 
 fail:
-	dev_dbg(&priv->i2c_client->dev,
-		 "%s: GAIN control error\n", __func__);
-	return err;
+  dev_dbg(&priv->i2c_client->dev,
+     "%s: GAIN control error\n", __func__);
+  return err;
 }
 
 static int imx219_set_frame_length(struct imx219 *priv, s32 val)
 {
-	u8 data[2];
-	int err;
+  u8 data[2];
+  int err;
 
-	dev_dbg(&priv->i2c_client->dev,
-		 "%s: val: %d\n", __func__, val);
+  dev_dbg(&priv->i2c_client->dev,
+     "%s: val: %d\n", __func__, val);
 
-	data[0] = (val >> 8) & 0xff;
-	data[1] = val & 0xff;
-	err = regmap_raw_write(priv->regmap, IMX219_FRAME_LENGTH_ADDR_MSB,
-		data, 2);
-	if (err)
-		goto fail;
+  data[0] = (val >> 8) & 0xff;
+  data[1] = val & 0xff;
+  err = regmap_raw_write(priv->regmap, IMX219_FRAME_LENGTH_ADDR_MSB,
+    data, 2);
+  if (err)
+    goto fail;
 
-	return 0;
+  return 0;
 
 fail:
-	dev_dbg(&priv->i2c_client->dev,
-		 "%s: FRAME_LENGTH control error\n", __func__);
-	return err;
+  dev_dbg(&priv->i2c_client->dev,
+     "%s: FRAME_LENGTH control error\n", __func__);
+  return err;
 }
 
 static int imx219_set_coarse_time(struct imx219 *priv, s32 val)
 {
-	u8 data[2];
-	int err;
+  u8 data[2];
+  int err;
 
-	dev_dbg(&priv->i2c_client->dev,
-		 "%s: val: %d\n", __func__, val);
+  dev_dbg(&priv->i2c_client->dev,
+     "%s: val: %d\n", __func__, val);
 
-	data[0] = (val >> 8) & 0xff;
-	data[1] = val & 0xff;
-	err = regmap_raw_write(priv->regmap, IMX219_COARSE_TIME_ADDR_MSB,
-		data, 2);
-	if (err)
-		goto fail;
+  data[0] = (val >> 8) & 0xff;
+  data[1] = val & 0xff;
+  err = regmap_raw_write(priv->regmap, IMX219_COARSE_TIME_ADDR_MSB,
+    data, 2);
+  if (err)
+    goto fail;
 
-	return 0;
+  return 0;
 
 fail:
-	dev_dbg(&priv->i2c_client->dev,
-		 "%s: COARSE_TIME control error\n", __func__);
-	return err;
+  dev_dbg(&priv->i2c_client->dev,
+     "%s: COARSE_TIME control error\n", __func__);
+  return err;
 }
 
 static int imx219_verify_streaming(struct imx219 *priv)
 {
-	int err = 0;
+  int err = 0;
 
-	err = camera_common_s_power(priv->subdev, true);
-	if (err)
-		return err;
+  err = camera_common_s_power(priv->subdev, true);
+  if (err)
+    return err;
 
-	err = imx219_s_stream(priv->subdev, true);
-	if (err)
-		goto error;
+  err = imx219_s_stream(priv->subdev, true);
+  if (err)
+    goto error;
 
 error:
-	imx219_s_stream(priv->subdev, false);
-	camera_common_s_power(priv->subdev, false);
+  imx219_s_stream(priv->subdev, false);
+  camera_common_s_power(priv->subdev, false);
 
-	return err;
+  return err;
 }
 
 static int imx219_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
 {
-	struct imx219 *priv =
-		container_of(ctrl->handler, struct imx219, ctrl_handler);
-	int err = 0;
+  struct imx219 *priv =
+    container_of(ctrl->handler, struct imx219, ctrl_handler);
+  int err = 0;
 
-	if (priv->power.state == SWITCH_OFF)
-		return 0;
+  if (priv->power.state == SWITCH_OFF)
+    return 0;
 
-	switch (ctrl->id) {
-	default:
-		pr_err("%s: unknown ctrl id.\n", __func__);
-		return -EINVAL;
-	}
+  switch (ctrl->id) {
+  default:
+    pr_err("%s: unknown ctrl id.\n", __func__);
+    return -EINVAL;
+  }
 
-	return err;
+  return err;
 }
 
 static int imx219_s_ctrl(struct v4l2_ctrl *ctrl)
 {
-	struct imx219 *priv =
-		container_of(ctrl->handler, struct imx219, ctrl_handler);
-	int err = 0;
-
-	if (priv->power.state == SWITCH_OFF)
-		return 0;
-
-	switch (ctrl->id) {
-	case TEGRA_CAMERA_CID_GAIN:
-		err = imx219_set_gain(priv, ctrl->val);
-		break;
-	case TEGRA_CAMERA_CID_FRAME_LENGTH:
-		err = imx219_set_frame_length(priv, ctrl->val);
-		break;
-	case TEGRA_CAMERA_CID_COARSE_TIME:
-		err = imx219_set_coarse_time(priv, ctrl->val);
-		break;
-	case TEGRA_CAMERA_CID_GROUP_HOLD:
-		err = imx219_set_group_hold(priv, ctrl->val);
-		break;
-	case TEGRA_CAMERA_CID_HDR_EN:
-		break;
-	case TEGRA_CAMERA_CID_FUSE_ID:
-		break;
-	default:
-		pr_err("%s: unknown ctrl id.\n", __func__);
-		return -EINVAL;
-	}
-
-	return err;
+  struct imx219 *priv =
+    container_of(ctrl->handler, struct imx219, ctrl_handler);
+  int err = 0;
+
+  if (priv->power.state == SWITCH_OFF)
+    return 0;
+
+  switch (ctrl->id) {
+  case TEGRA_CAMERA_CID_GAIN:
+    err = imx219_set_gain(priv, ctrl->val);
+    break;
+  case TEGRA_CAMERA_CID_FRAME_LENGTH:
+    err = imx219_set_frame_length(priv, ctrl->val);
+    break;
+  case TEGRA_CAMERA_CID_COARSE_TIME:
+    err = imx219_set_coarse_time(priv, ctrl->val);
+    break;
+  case TEGRA_CAMERA_CID_GROUP_HOLD:
+    err = imx219_set_group_hold(priv, ctrl->val);
+    break;
+  case TEGRA_CAMERA_CID_HDR_EN:
+    break;
+  case TEGRA_CAMERA_CID_FUSE_ID:
+    break;
+  default:
+    pr_err("%s: unknown ctrl id.\n", __func__);
+    return -EINVAL;
+  }
+
+  return err;
 }
 
 static int imx219_ctrls_init(struct imx219 *priv)
 {
-	struct i2c_client *client = priv->i2c_client;
-	struct v4l2_ctrl *ctrl;
-	int num_ctrls;
-	int err;
-	int i;
-
-	dev_info(&client->dev, "%s++\n", __func__);
-
-	num_ctrls = ARRAY_SIZE(ctrl_config_list);
-	v4l2_ctrl_handler_init(&priv->ctrl_handler, num_ctrls);
-
-	for (i = 0; i < num_ctrls; i++) {
-		ctrl = v4l2_ctrl_new_custom(&priv->ctrl_handler,
-			&ctrl_config_list[i], NULL);
-		if (ctrl == NULL) {
-			dev_err(&client->dev, "Failed to init %s ctrl\n",
-				ctrl_config_list[i].name);
-			continue;
-		}
-
-		if (ctrl_config_list[i].type == V4L2_CTRL_TYPE_STRING &&
-			ctrl_config_list[i].flags & V4L2_CTRL_FLAG_READ_ONLY) {
-			ctrl->p_new.p_char = devm_kzalloc(&client->dev,
-				ctrl_config_list[i].max + 1, GFP_KERNEL);
-			if (!ctrl->p_new.p_char) {
-				dev_err(&client->dev,
-					"Failed to allocate otp data\n");
-				return -ENOMEM;
-			}
-		}
-		priv->ctrls[i] = ctrl;
-	}
-
-	priv->num_ctrls = num_ctrls;
-	priv->subdev->ctrl_handler = &priv->ctrl_handler;
-	if (priv->ctrl_handler.error) {
-		dev_err(&client->dev, "Error %d adding controls\n",
-			priv->ctrl_handler.error);
-		err = priv->ctrl_handler.error;
-		goto error;
-	}
-
-	err = v4l2_ctrl_handler_setup(&priv->ctrl_handler);
-	if (err) {
-		dev_err(&client->dev,
-			"Error %d setting default controls\n", err);
-		goto error;
-	}
-
-	return 0;
+  struct i2c_client *client = priv->i2c_client;
+  struct v4l2_ctrl *ctrl;
+  int numctrls;
+  int err;
+  int i;
+
+  dev_info(&client->dev, "%s++\n", __func__);
+
+  numctrls = ARRAY_SIZE(ctrl_config_list);
+  v4l2_ctrl_handler_init(&priv->ctrl_handler, numctrls);
+
+  for (i = 0; i < numctrls; i++) {
+    ctrl = v4l2_ctrl_new_custom(&priv->ctrl_handler,
+      &ctrl_config_list[i], NULL);
+    if (ctrl == NULL) {
+      dev_err(&client->dev, "Failed to init %s ctrl\n",
+        ctrl_config_list[i].name);
+      continue;
+    }
+
+    if (ctrl_config_list[i].type == V4L2_CTRL_TYPE_STRING &&
+      ctrl_config_list[i].flags & V4L2_CTRL_FLAG_READ_ONLY) {
+      ctrl->p_new.p_char = devm_kzalloc(&client->dev,
+        ctrl_config_list[i].max + 1, GFP_KERNEL);
+      if (!ctrl->p_new.p_char)
+        return -ENOMEM;
+    }
+    priv->ctrls[i] = ctrl;
+  }
+
+  priv->numctrls = numctrls;
+  priv->subdev->ctrl_handler = &priv->ctrl_handler;
+  if (priv->ctrl_handler.error) {
+    dev_err(&client->dev, "Error %d adding controls\n",
+      priv->ctrl_handler.error);
+    err = priv->ctrl_handler.error;
+    goto error;
+  }
+
+  err = v4l2_ctrl_handler_setup(&priv->ctrl_handler);
+  if (err) {
+    dev_err(&client->dev,
+      "Error %d setting default controls\n", err);
+    goto error;
+  }
+
+  err = imx219_verify_streaming(priv);
+  if (err) {
+    dev_info(&client->dev, "Failed to verify streaming\n");
+    goto error;
+  }
+
+  return 0;
 
 error:
-	v4l2_ctrl_handler_free(&priv->ctrl_handler);
-	return err;
+  v4l2_ctrl_handler_free(&priv->ctrl_handler);
+  return err;
 }
 
 MODULE_DEVICE_TABLE(of, imx219_of_match);
 
 static struct camera_common_pdata *imx219_parse_dt(struct i2c_client *client)
 {
-	struct device_node *np = client->dev.of_node;
-	struct camera_common_pdata *board_priv_pdata;
-	const struct of_device_id *match;
-	int gpio, err;
-	struct camera_common_pdata *ret = NULL;
-
-	match = of_match_device(imx219_of_match, &client->dev);
-	if (!match) {
-		dev_err(&client->dev, "Failed to find matching dt id\n");
-		return NULL;
-	}
-
-	board_priv_pdata = devm_kzalloc(&client->dev,
-			   sizeof(*board_priv_pdata), GFP_KERNEL);
-	if (!board_priv_pdata) {
-		dev_err(&client->dev, "Failed to allocate pdata\n");
-		return NULL;
-	}
-
-	err = of_property_read_string(np, "mclk", &board_priv_pdata->mclk_name);
-	if (err) {
-		dev_err(&client->dev, "mclk not in DT\n");
-		goto error;
-	}
-
-	gpio = of_get_named_gpio(np, "reset-gpios", 0);
-	if (gpio < 0) {
-		if (gpio == -EPROBE_DEFER) {
-			ret = ERR_PTR(-EPROBE_DEFER);
-			goto error;
-		}
-		dev_err(&client->dev, "reset gpios not in DT\n");
-		goto error;
-	}
-	board_priv_pdata->reset_gpio = (unsigned int)gpio;
-
-	err = of_property_read_string(np, "avdd-reg",
-			&board_priv_pdata->regulators.avdd);
-	if (err) {
-		dev_err(&client->dev, "avdd-reg not in DT\n");
-		goto error;
-	}
-	err = of_property_read_string(np, "dvdd-reg",
-			&board_priv_pdata->regulators.dvdd);
-	if (err) {
-		dev_err(&client->dev, "dvdd-reg not in DT\n");
-		goto error;
-	}
-	err = of_property_read_string(np, "iovdd-reg",
-			&board_priv_pdata->regulators.iovdd);
-	if (err) {
-		dev_err(&client->dev, "iovdd-reg not in DT\n");
-		goto error;
-	}
-
-	return board_priv_pdata;
+  struct device_node *node = client->dev.of_node;
+  struct camera_common_pdata *board_priv_pdata;
+  const struct of_device_id *match;
+  int gpio;
+  int err;
+  struct camera_common_pdata *ret = NULL;
+
+  if (!node)
+    return NULL;
+
+  match = of_match_device(imx219_of_match, &client->dev);
+  if (!match) {
+    dev_err(&client->dev, "Failed to find matching dt id\n");
+    return NULL;
+  }
+
+  board_priv_pdata = devm_kzalloc(&client->dev,
+         sizeof(*board_priv_pdata), GFP_KERNEL);
+  if (!board_priv_pdata)
+    return NULL;
+
+  err = camera_common_parse_clocks(&client->dev, board_priv_pdata);
+  if (err) {
+    dev_err(&client->dev, "Failed to find clocks\n");
+    goto error;
+  }
+
+  gpio = of_get_named_gpio(node, "pwdn-gpios", 0);
+  if (gpio < 0) {
+    if (gpio == -EPROBE_DEFER) {
+      ret = ERR_PTR(-EPROBE_DEFER);
+      goto error;
+    }
+    dev_err(&client->dev, "pwdn gpios not in DT\n");
+    gpio = 0;
+  }
+  board_priv_pdata->pwdn_gpio = (unsigned int)gpio;
+
+  gpio = of_get_named_gpio(node, "reset-gpios", 0);
+  if (gpio < 0) {
+    /* reset-gpio is not absolutely needed */
+    if (gpio == -EPROBE_DEFER) {
+      ret = ERR_PTR(-EPROBE_DEFER);
+      goto error;
+    }
+    dev_dbg(&client->dev, "reset gpios not in DT\n");
+    gpio = 0;
+  }
+  board_priv_pdata->reset_gpio = (unsigned int)gpio;
+
+  board_priv_pdata->use_cam_gpio =
+    of_property_read_bool(node, "cam,use-cam-gpio");
+
+  of_property_read_string(node, "avdd-reg",
+      &board_priv_pdata->regulators.avdd);
+  of_property_read_string(node, "iovdd-reg",
+      &board_priv_pdata->regulators.iovdd);
+  of_property_read_string(node, "dvdd-reg",
+      &board_priv_pdata->regulators.dvdd);
+
+  return board_priv_pdata;
 
 error:
-	devm_kfree(&client->dev, board_priv_pdata);
-	return ret;
+  devm_kfree(&client->dev, board_priv_pdata);
+  return ret;
 }
 
 static int imx219_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
 {
-	struct i2c_client *client = v4l2_get_subdevdata(sd);
-	dev_dbg(&client->dev, "%s:\n", __func__);
-
-	return 0;
+  struct i2c_client *client = v4l2_get_subdevdata(sd);
+  dev_info(&client->dev, "%s:\n", __func__);
+  return 0;
 }
 
 static const struct v4l2_subdev_internal_ops imx219_subdev_internal_ops = {
-	.open = imx219_open,
+  .open = imx219_open,
 };
 
 static const struct media_entity_operations imx219_media_ops = {
-	.link_validate = v4l2_subdev_link_validate,
+  .link_validate = v4l2_subdev_link_validate,
 };
 
 static int imx219_probe(struct i2c_client *client,
-			const struct i2c_device_id *id)
+      const struct i2c_device_id *id)
 {
-	struct camera_common_data *common_data;
-	struct device_node *node = client->dev.of_node;
-	struct imx219 *priv;
-	int err;
-
-	if (!IS_ENABLED(CONFIG_OF) || !node)
-		return -EINVAL;
-
-	common_data = devm_kzalloc(&client->dev,
-			    sizeof(struct camera_common_data), GFP_KERNEL);
-	if (!common_data) {
-		dev_err(&client->dev, "unable to allocate memory!\n");
-		return -ENOMEM;
-	}
-
-	priv = devm_kzalloc(&client->dev,
-			    sizeof(struct imx219) + sizeof(struct v4l2_ctrl *) *
-			    ARRAY_SIZE(ctrl_config_list),
-			    GFP_KERNEL);
-	if (!priv) {
-		dev_err(&client->dev, "unable to allocate memory!\n");
-		return -ENOMEM;
-	}
-
-	priv->regmap = devm_regmap_init_i2c(client, &sensor_regmap_config);
-	if (IS_ERR(priv->regmap)) {
-		dev_err(&client->dev,
-			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
-		return -ENODEV;
-	}
-
-	priv->pdata = imx219_parse_dt(client);
-	if (PTR_ERR(priv->pdata) == -EPROBE_DEFER) {
-		devm_kfree(&client->dev, priv);
-		return -EPROBE_DEFER;
-	}
-	if (!priv->pdata) {
-		dev_err(&client->dev, "unable to get platform data\n");
-		return -EFAULT;
-	}
-
-	common_data->ops		= &imx219_common_ops;
-	common_data->ctrl_handler	= &priv->ctrl_handler;
-	common_data->dev		= &client->dev;
-	common_data->frmfmt		= &imx219_frmfmt[0];
-	common_data->colorfmt		= camera_common_find_datafmt(
-					  IMX219_DEFAULT_DATAFMT);
-	common_data->power		= &priv->power;
-	common_data->ctrls		= priv->ctrls;
-	common_data->priv		= (void *)priv;
-	common_data->numctrls		= ARRAY_SIZE(ctrl_config_list);
-	common_data->numfmts		= ARRAY_SIZE(imx219_frmfmt);
-	common_data->def_mode		= IMX219_DEFAULT_MODE;
-	common_data->def_width		= IMX219_DEFAULT_WIDTH;
-	common_data->def_height		= IMX219_DEFAULT_HEIGHT;
-	common_data->fmt_width		= common_data->def_width;
-	common_data->fmt_height		= common_data->def_height;
-	common_data->def_clk_freq	= IMX219_DEFAULT_CLK_FREQ;
-
-	priv->i2c_client		= client;
-	priv->s_data			= common_data;
-	priv->subdev			= &common_data->subdev;
-	priv->subdev->dev		= &client->dev;
-
-	err = imx219_power_get(priv);
-	if (err)
-		return err;
-
-	err = camera_common_initialize(common_data, "imx219");
-	if (err)
-		return err;
-
-	v4l2_i2c_subdev_init(&common_data->subdev, client, &imx219_subdev_ops);
-
-	err = imx219_ctrls_init(priv);
-	if (err)
-		return err;
-
-	err = imx219_verify_streaming(priv);
-	if (err)
-		return err;
-
-	priv->subdev->internal_ops = &imx219_subdev_internal_ops;
-	priv->subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
-		     V4L2_SUBDEV_FL_HAS_EVENTS;
+  struct camera_common_data *common_data;
+  struct device_node *node = client->dev.of_node;
+  struct imx219 *priv;
+  char debugfs_name[32];
+  int err;
+
+  pr_info("[IMX219]: probing v4l2 sensor.\n");
+
+  if (!IS_ENABLED(CONFIG_OF) || !node)
+    return -EINVAL;
+
+  common_data = devm_kzalloc(&client->dev,
+    sizeof(struct camera_common_data), GFP_KERNEL);
+  if (!common_data) {
+    dev_err(&client->dev, "unable to allocate memory!\n");
+    return -ENOMEM;
+  }
+
+  priv = devm_kzalloc(&client->dev,
+    sizeof(struct imx219) + sizeof(struct v4l2_ctrl *) *
+    ARRAY_SIZE(ctrl_config_list),
+    GFP_KERNEL);
+  if (!priv) {
+    dev_err(&client->dev, "unable to allocate memory!\n");
+    return -ENOMEM;
+  }
+
+  priv->regmap = devm_regmap_init_i2c(client, &imx219_regmap_config);
+  if (IS_ERR(priv->regmap)) {
+    dev_err(&client->dev,
+      "regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+    return -ENODEV;
+  }
+
+  priv->pdata = imx219_parse_dt(client);
+  if (PTR_ERR(priv->pdata) == -EPROBE_DEFER)
+    return -EPROBE_DEFER;
+  if (!priv->pdata) {
+    dev_err(&client->dev, "unable to get platform data\n");
+    return -EFAULT;
+  }
+
+  common_data->ops    = &imx219_common_ops;
+  common_data->ctrl_handler = &priv->ctrl_handler;
+  common_data->dev    = &client->dev;
+  common_data->frmfmt       = &imx219_frmfmt[0];
+  common_data->colorfmt     = camera_common_find_datafmt(IMX219_DEFAULT_DATAFMT);
+  common_data->power  = &priv->power;
+  common_data->ctrls  = priv->ctrls;
+  common_data->priv   = (void *)priv;
+  common_data->numctrls     = ARRAY_SIZE(ctrl_config_list);
+  common_data->numfmts      = ARRAY_SIZE(imx219_frmfmt);
+  common_data->def_mode     = IMX219_DEFAULT_MODE;
+  common_data->def_width    = IMX219_DEFAULT_WIDTH;
+  common_data->def_height   = IMX219_DEFAULT_HEIGHT;
+  common_data->fmt_width    = common_data->def_width;
+  common_data->fmt_height   = common_data->def_height;
+  common_data->def_clk_freq = IMX219_DEFAULT_CLK_FREQ;
+
+  priv->i2c_client    = client;
+  priv->s_data        = common_data;
+  priv->subdev        = &common_data->subdev;
+  priv->subdev->dev   = &client->dev;
+  priv->s_data->dev   = &client->dev;
+
+  err = imx219_power_get(priv);
+  if (err)
+    return err;
+
+  err = camera_common_initialize(common_data, "imx219");
+  if (err) {
+    dev_err(&client->dev, "Failed to initialize imx219.\n");
+    return err;
+  }
+
+  sprintf(debugfs_name, "imx219_%c", common_data->csi_port + 'a');
+  dev_dbg(&client->dev, "%s: name %s\n", __func__, debugfs_name);
+  camera_common_create_debugfs(common_data, debugfs_name);
+
+  v4l2_i2c_subdev_init(priv->subdev, client, &imx219_subdev_ops);
+
+  err = imx219_ctrls_init(priv);
+  if (err)
+    return err;
+
+  priv->subdev->internal_ops = &imx219_subdev_internal_ops;
+  priv->subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+       V4L2_SUBDEV_FL_HAS_EVENTS;
 
 #if defined(CONFIG_MEDIA_CONTROLLER)
-	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
-	priv->subdev->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
-	priv->subdev->entity.ops = &imx219_media_ops;
-	err = media_entity_init(&priv->subdev->entity, 1, &priv->pad, 0);
-	if (err < 0) {
-		dev_err(&client->dev, "unable to init media entity\n");
-		return err;
-	}
+  priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+  priv->subdev->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+  priv->subdev->entity.ops = &imx219_media_ops;
+  err = media_entity_init(&priv->subdev->entity, 1, &priv->pad, 0);
+  if (err < 0) {
+    dev_err(&client->dev, "unable to init media entity\n");
+    return err;
+  }
 #endif
 
-	err = v4l2_async_register_subdev(priv->subdev);
-	if (err)
-		return err;
+  err = v4l2_async_register_subdev(priv->subdev);
+  if (err)
+    return err;
 
-	dev_dbg(&client->dev, "Detected IMX219 sensor\n");
+  dev_info(&client->dev, "Detected IMX219 sensor\n");
 
-	return 0;
+  return 0;
 }
 
 static int
 imx219_remove(struct i2c_client *client)
 {
-	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
-	struct imx219 *priv = (struct imx219 *)s_data->priv;
+  struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+  struct imx219 *priv = (struct imx219 *)s_data->priv;
 
-	v4l2_async_unregister_subdev(priv->subdev);
+  v4l2_async_unregister_subdev(priv->subdev);
 #if defined(CONFIG_MEDIA_CONTROLLER)
-	media_entity_cleanup(&priv->subdev->entity);
+  media_entity_cleanup(&priv->subdev->entity);
 #endif
 
-	v4l2_ctrl_handler_free(&priv->ctrl_handler);
-	imx219_power_put(priv);
-	camera_common_cleanup(s_data);
+  v4l2_ctrl_handler_free(&priv->ctrl_handler);
+  imx219_power_put(priv);
+  camera_common_remove_debugfs(s_data);
 
-	return 0;
+  return 0;
 }
 
 static const struct i2c_device_id imx219_id[] = {
-	{ "imx219", 0 },
-	{ }
+  { "imx219", 0 },
+  { }
 };
 
 MODULE_DEVICE_TABLE(i2c, imx219_id);
 
 static struct i2c_driver imx219_i2c_driver = {
-	.driver = {
-		.name = "imx219",
-		.owner = THIS_MODULE,
-		.of_match_table = of_match_ptr(imx219_of_match),
-	},
-	.probe = imx219_probe,
-	.remove = imx219_remove,
-	.id_table = imx219_id,
+  .driver = {
+    .name = "imx219",
+    .owner = THIS_MODULE,
+    .of_match_table = of_match_ptr(imx219_of_match),
+  },
+  .probe = imx219_probe,
+  .remove = imx219_remove,
+  .id_table = imx219_id,
 };
 
 module_i2c_driver(imx219_i2c_driver);
@@ -871,3 +1052,4 @@ module_i2c_driver(imx219_i2c_driver);
 MODULE_DESCRIPTION("SoC Camera driver for Sony IMX219");
 MODULE_AUTHOR("Bryan Wu <pengw@nvidia.com>");
 MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/media/i2c/imx219_mode_tbls.h b/drivers/media/i2c/imx219_mode_tbls.h
index 8bf129f..d720cd4 100644
--- a/drivers/media/i2c/imx219_mode_tbls.h
+++ b/drivers/media/i2c/imx219_mode_tbls.h
@@ -22,367 +22,286 @@
 #define IMX219_TABLE_WAIT_MS 0
 #define IMX219_TABLE_END 1
 #define IMX219_MAX_RETRIES 3
-#define IMX219_WAIT_MS 3
-
-static struct reg_8 mode_3280x2464[] = {
-	{IMX219_TABLE_WAIT_MS, 10},
-	/* software reset */
-	{0x0103, 0x01},
-	/* global settings */
-	{0x30EB, 0x05},
-	{0x30EB, 0x0C},
-	{0x300A, 0xFF},
-	{0x300B, 0xFF},
-	{0x30EB, 0x05},
-	{0x30EB, 0x09},
-	{0x0114, 0x01},
-	{0x0128, 0x00},
-	{0x012A, 0x0C},
-	{0x012B, 0x00},
-	{0x0160, 0x09},
-	{0x0161, 0xC3},
-	{0x0162, 0x0D},
-	{0x0163, 0x78},
-	{0x0164, 0x00},
-	{0x0165, 0x00},
-	{0x0166, 0x0C},
-	{0x0167, 0xCF},
-	{0x0168, 0x00},
-	{0x0169, 0x00},
-	{0x016A, 0x09},
-	{0x016B, 0x9F},
-	{0x016C, 0x0C},
-	{0x016D, 0xD0},
-	{0x016E, 0x09},
-	{0x016F, 0xA0},
-	{0x0170, 0x01},
-	{0x0171, 0x01},
-	{0x0174, 0x00},
-	{0x0175, 0x00},
-	{0x018C, 0x0A},
-	{0x018D, 0x0A},
-	{0x0301, 0x05},
-	{0x0303, 0x01},
-	{0x0304, 0x02},
-	{0x0305, 0x02},
-	{0x0306, 0x00},
-	{0x0307, 0x4C},
-	{0x0309, 0x0A},
-	{0x030B, 0x01},
-	{0x030C, 0x00},
-	{0x030D, 0x98},
-	{0x4767, 0x0F},
-	{0x4750, 0x14},
-	{0x47B4, 0x14},
-	/* stream on */
-	{0x0100, 0x01},
-	{IMX219_TABLE_WAIT_MS, IMX219_WAIT_MS},
-	{IMX219_TABLE_END, 0x00}
+//#define IMX219_WAIT_MS 3
+#define IMX219_WAIT_MS    10
+
+static struct reg_8 imx219_start[] = {
+  { 0x0100, 0x01 }, /* mode select streaming on */
+  { IMX219_TABLE_END, 0x00 }
 };
 
-static struct reg_8 mode_3280x2460[] = {
-	{IMX219_TABLE_WAIT_MS, 10},
-	/* software reset */
-	{0x0103, 0x01},
-	/* global settings */
-	{0x30EB, 0x05},
-	{0x30EB, 0x0C},
-	{0x300A, 0xFF},
-	{0x300B, 0xFF},
-	{0x30EB, 0x05},
-	{0x30EB, 0x09},
-	{0x0114, 0x03},
-	{0x0128, 0x00},
-	{0x012A, 0x18},
-	{0x012B, 0x00},
-	/* Bank A Settings */
-	{0x0157, 0x00},
-	{0x015A, 0x08},
-	{0x015B, 0x8F},
-	{0x0160, 0x0A},
-	{0x0161, 0x83},
-	{0x0162, 0x0D},
-	{0x0163, 0x78},
-	{0x0164, 0x00},
-	{0x0165, 0x00},
-	{0x0166, 0x0C},
-	{0x0167, 0xCF},
-	{0x0168, 0x00},
-	{0x0169, 0x00},
-	{0x016A, 0x09},
-	{0x016B, 0x9F},
-	{0x016C, 0x0C},
-	{0x016D, 0xD0},
-	{0x016E, 0x09},
-	{0x016F, 0x9C},
-	{0x0170, 0x01},
-	{0x0171, 0x01},
-	{0x0174, 0x00},
-	{0x0175, 0x00},
-	{0x018C, 0x0A},
-	{0x018D, 0x0A},
-	/* Bank B Settings */
-	{0x0257, 0x00},
-	{0x025A, 0x08},
-	{0x025B, 0x8F},
-	{0x0260, 0x0A},
-	{0x0261, 0x83},
-	{0x0262, 0x0D},
-	{0x0263, 0x78},
-	{0x0264, 0x00},
-	{0x0265, 0x00},
-	{0x0266, 0x0C},
-	{0x0267, 0xCF},
-	{0x0268, 0x00},
-	{0x0269, 0x00},
-	{0x026A, 0x09},
-	{0x026B, 0x9F},
-	{0x026C, 0x0C},
-	{0x026D, 0xD0},
-	{0x026E, 0x09},
-	{0x026F, 0x9C},
-	{0x0270, 0x01},
-	{0x0271, 0x01},
-	{0x0274, 0x00},
-	{0x0275, 0x00},
-	{0x028C, 0x0A},
-	{0x028D, 0x0A},
-	/* clock setting */
-	{0x0301, 0x05},
-	{0x0303, 0x01},
-	{0x0304, 0x03},
-	{0x0305, 0x03},
-	{0x0306, 0x00},
-	{0x0307, 0x57},
-	{0x0309, 0x0A},
-	{0x030B, 0x01},
-	{0x030C, 0x00},
-	{0x030D, 0x5A},
-	{0x455E, 0x00},
-	{0x471E, 0x4B},
-	{0x4767, 0x0F},
-	{0x4750, 0x14},
-	{0x4540, 0x00},
-	{0x47B4, 0x14},
-	{0x4713, 0x30},
-	{0x478B, 0x10},
-	{0x478F, 0x10},
-	{0x4793, 0x10},
-	{0x4797, 0x0E},
-	{0x479B, 0x0E},
-	/* stream on */
-	{0x0100, 0x01},
-	{IMX219_TABLE_WAIT_MS, IMX219_WAIT_MS},
-	{IMX219_TABLE_END, 0x00}
+static struct reg_8 imx219_stop[] = {
+  { 0x0100, 0x00 }, /* mode select streaming off */
+  { IMX219_TABLE_END, 0x00 }
 };
-static struct reg_8 mode_3280x1846[] = {
-	{IMX219_TABLE_WAIT_MS, 10},
-	/* software reset */
-	{0x0103, 0x01},
-	/* global settings */
-	{0x30EB, 0x05},
-	{0x30EB, 0x0C},
-	{0x300A, 0xFF},
-	{0x300B, 0xFF},
-	{0x30EB, 0x05},
-	{0x30EB, 0x09},
-	{0x0114, 0x03},
-	{0x0128, 0x00},
-	{0x012A, 0x18},
-	{0x012B, 0x00},
-	/* Bank A Settings */
-	{0x0157, 0x00},
-	{0x015A, 0x08},
-	{0x015B, 0x8F},
-	{0x0160, 0x07},
-	{0x0161, 0x5E},
-	{0x0162, 0x0D},
-	{0x0163, 0x78},
-	{0x0164, 0x00},
-	{0x0165, 0x00},
-	{0x0166, 0x0C},
-	{0x0167, 0xCF},
-	{0x0168, 0x01},
-	{0x0169, 0x36},
-	{0x016A, 0x08},
-	{0x016B, 0x6B},
-	{0x016C, 0x0C},
-	{0x016D, 0xD0},
-	{0x016E, 0x07},
-	{0x016F, 0x36},
-	{0x0170, 0x01},
-	{0x0171, 0x01},
-	{0x0174, 0x00},
-	{0x0175, 0x00},
-	{0x018C, 0x0A},
-	{0x018D, 0x0A},
-	/* Bank B Settings */
-	{0x0257, 0x00},
-	{0x025A, 0x08},
-	{0x025B, 0x8F},
-	{0x0260, 0x07},
-	{0x0261, 0x5E},
-	{0x0262, 0x0D},
-	{0x0263, 0x78},
-	{0x0264, 0x00},
-	{0x0265, 0x00},
-	{0x0266, 0x0C},
-	{0x0267, 0xCF},
-	{0x0268, 0x01},
-	{0x0269, 0x36},
-	{0x026A, 0x08},
-	{0x026B, 0x6B},
-	{0x026C, 0x0C},
-	{0x026D, 0xD0},
-	{0x026E, 0x07},
-	{0x026F, 0x36},
-	{0x0270, 0x01},
-	{0x0271, 0x01},
-	{0x0274, 0x00},
-	{0x0275, 0x00},
-	{0x028C, 0x0A},
-	{0x028D, 0x0A},
-	/* clock setting */
-	{0x0301, 0x05},
-	{0x0303, 0x01},
-	{0x0304, 0x03},
-	{0x0305, 0x03},
-	{0x0306, 0x00},
-	{0x0307, 0x57},
-	{0x0309, 0x0A},
-	{0x030B, 0x01},
-	{0x030C, 0x00},
-	{0x030D, 0x5A},
-	{0x455E, 0x00},
-	{0x471E, 0x4B},
-	{0x4767, 0x0F},
-	{0x4750, 0x14},
-	{0x4540, 0x00},
-	{0x47B4, 0x14},
-	{0x4713, 0x30},
-	{0x478B, 0x10},
-	{0x478F, 0x10},
-	{0x4793, 0x10},
-	{0x4797, 0x0E},
-	{0x479B, 0x0E},
-	/* stream on */
-	{0x0100, 0x01},
+
+/* 0.912 GHz */
+static struct reg_8 mode_1920x1080[] = {
+  {IMX219_TABLE_WAIT_MS, 10},
+
+  /* analogue gain setting */
+  {0x0157, 0x00},
+  /* 0x0158, 0x159 Digital gain */
+
+  /* line length: 3448 */
+  //{0x0162, 0x0D}, {0x0163, 0x78},
+  /* line length: 3559 */
+  {0x0162, 0x0D}, {0x0163, 0xE7},
+
+  /* Frame Length: 1766 */
+  //{0x0160, 0x06}, {0x0161, 0xE6},
+  {0x0160, 0x0D}, {0x0161, 0x09},
+
+  /* Coarse Time */
+  {0x015A, 0x0D}, {0x015B, 0x05},
+
+
+  /* Image Width: 2599 - 680 = 1920 - 1 */
+  /* crop_rect.left: 680 Offset */
+  {0x0164, 0x02}, {0x0165, 0xA8},
+  //{0x0164, 0x02}, {0x0165, 0xAA},
+  /* crop_rect.width - 1: 2599 */
+  {0x0166, 0x0A}, {0x0167, 0x27},
+  //{0x0166, 0x0A}, {0x0167, 0x29},
+
+
+  /* Image Height: 1771 - 692 = 1080 - 1 */
+  /* crop_rect.top: 692 */
+  {0x0168, 0x02}, {0x0169, 0xB4},
+  /* crop_rect.height - 1: 1771 */
+  {0x016A, 0x06}, {0x016B, 0xEB},
+
+
+  /* crop_rect.width: 1920 */
+  {0x016C, 0x07}, {0x016D, 0x80},
+  /* crop_rect.height: 1080 */
+  {0x016E, 0x04}, {0x016F, 0x38},
+
+
+  /* X odd increment: 1 */
+  {0x0170, 0x01},
+
+  /* Y odd increment: 1 */
+  {0x0171, 0x01},
+
+  /* Binning Mode Horizontal: 1 (no binning) */
+  //{0x0174, 0x00},
+  {0x0174, 0x00},
+
+  /* Binning Mode Horizontal: 1 (no binning) */
+  //{0x0175, 0x00},
+  {0x0175, 0x00},
+
 	{IMX219_TABLE_WAIT_MS, IMX219_WAIT_MS},
-	{IMX219_TABLE_END, 0x00}
+  {IMX219_TABLE_END, 0x00 }
 };
 
 static struct reg_8 mode_1280x720[] = {
-	{IMX219_TABLE_WAIT_MS, 10},
-	/* software reset */
-	{0x0103, 0x01},
-	/* global settings */
-	{0x30EB, 0x05},
-	{0x30EB, 0x0C},
-	{0x300A, 0xFF},
-	{0x300B, 0xFF},
-	{0x30EB, 0x05},
-	{0x30EB, 0x09},
-	{0x0114, 0x03},
-	{0x0128, 0x00},
-	{0x012A, 0x18},
-	{0x012B, 0x00},
-	/* Bank A Settings */
-	{0x0160, 0x02},
-	{0x0161, 0x8C},
-	{0x0162, 0x0D},
-	{0x0163, 0xE8},
-	{0x0164, 0x01},
-	{0x0165, 0x68},
-	{0x0166, 0x0B},
-	{0x0167, 0x67},
-	{0x0168, 0x02},
-	{0x0169, 0x00},
-	{0x016A, 0x07},
-	{0x016B, 0x9F},
-	{0x016C, 0x05},
-	{0x016D, 0x00},
-	{0x016E, 0x02},
-	{0x016F, 0xD0},
-	{0x0170, 0x01},
-	{0x0171, 0x01},
-	{0x0174, 0x03},
-	{0x0175, 0x03},
-	{0x018C, 0x0A},
-	{0x018D, 0x0A},
-	/* Bank B Settings */
-	{0x0260, 0x02},
-	{0x0261, 0x8C},
-	{0x0262, 0x0D},
-	{0x0263, 0xE8},
-	{0x0264, 0x01},
-	{0x0265, 0x68},
-	{0x0266, 0x0B},
-	{0x0267, 0x67},
-	{0x0268, 0x02},
-	{0x0269, 0x00},
-	{0x026A, 0x07},
-	{0x026B, 0x9F},
-	{0x026C, 0x05},
-	{0x026D, 0x00},
-	{0x026E, 0x02},
-	{0x026F, 0xD0},
-	{0x0270, 0x01},
-	{0x0271, 0x01},
-	{0x0274, 0x03},
-	{0x0275, 0x03},
-	{0x028C, 0x0A},
-	{0x028D, 0x0A},
-	/* clock setting */
-	{0x0301, 0x05},
-	{0x0303, 0x01},
-	{0x0304, 0x03},
-	{0x0305, 0x03},
-	{0x0306, 0x00},
-	{0x0307, 0x57},
-	{0x0309, 0x0A},
-	{0x030B, 0x01},
-	{0x030C, 0x00},
-	{0x030D, 0x5A},
-	{0x455E, 0x00},
-	{0x471E, 0x4B},
-	{0x4767, 0x0F},
-	{0x4750, 0x14},
-	{0x4540, 0x00},
-	{0x47B4, 0x14},
-	{0x4713, 0x30},
-	{0x478B, 0x10},
-	{0x478F, 0x10},
-	{0x4793, 0x10},
-	{0x4797, 0x0E},
-	{0x479B, 0x0E},
-	/* stream on */
-	{0x0100, 0x01},
+  {IMX219_TABLE_WAIT_MS, 10},
+
+  // analogue gain setting
+  //{0x0157, 0xC7},
+  {0x0157, 0x00},
+
+
+  // Coarse Time
+  //{0x015A, 0x04}, {0x015B, 0x22},
+  //{0x015A, 0x0D}, {0x015B, 0x05},
+
+  //{0x015A, 0x03}, {0x015B, 0x51},
+
+  // 30 FPS
+  // Frame Length: 853
+  //{0x0160, 0x03}, {0x0161, 0x55},
+  {0x0160, 0x02}, {0x0161, 0x8C},
+
+  // Line Length: 3449
+  {0x0162, 0x0D}, {0x0163, 0x78},
+
+  // Image Width: 2279 - 360 = 1920 - 1 (1279)
+  // crop_rect.left: 1000
+  //{0x0164, 0x03}, {0x0165, 0xE8},
+
+
+  // crop_rect.left: 360
+  {0x0164, 0x01}, {0x0165, 0x68},
+
+  // crop_rect.width: 2279
+  {0x0166, 0x0B}, {0x0167, 0x67},
+
+  // Image Height: 1591 - 872 = 720 - 1 (719)
+  // crop_rect.top: 872
+  //{0x0168, 0x03}, {0x0169, 0x68},
+  {0x0168, 0x02}, {0x0169, 0x00},
+
+  // crop_rect.height: 1591
+  //{0x016A, 0x06}, {0x016B, 0x37},
+  {0x016A, 0x07}, {0x016B, 0x9F},
+
+  // image width = 1280
+  {0x016C, 0x05}, {0x016D, 0x00},
+  //{0x016C, 0x0D}, {0x016D, 0xD0},
+  // image height = 720
+  {0x016E, 0x02}, {0x016F, 0xD0},
+
+  // X odd increment
+  {0x0170, 0x01},
+
+  // Y odd increment
+  {0x0171, 0x01},
+
+  // Binning Mode: X (1)
+  //{0x0174, 0x00},
+  {0x0174, 0x03},
+  //{0x0174, 0x01},
+
+  // Binning Mode: Y (1)
+  //{0x0175, 0x00}
+  {0x0175, 0x03},
+  //{0x0175, 0x01}
+
 	{IMX219_TABLE_WAIT_MS, IMX219_WAIT_MS},
-	{IMX219_TABLE_END, 0x00}
+  {IMX219_TABLE_END, 0x00 }
+};
+
+static struct reg_8 mode_table_common[] = {
+  /* software reset */
+  {0x0103, 0x01},
+  {0x0100, 0x00},
+
+  //{0x6620, 0x01}, {0x6621, 0x01},
+  //{0x6622, 0x01}, {0x6623, 0x01},
+
+  /* Access Code to registers over 0x3000 */
+  {0x30EB, 0x05},
+  {0x30EB, 0x0C},
+  {0x300A, 0xFF},
+  {0x300B, 0xFF},
+  {0x30EB, 0x05},
+  {0x30EB, 0x09},
+
+  /* number of csi lanes = 2 (1 + 1) */
+  {0x0114, 0x01},
+
+  /* dphy control: Auto */
+  {0x0128, 0x00},
+
+  /* external clock frequency = 24MHz */
+  {0x012A, 0x18}, // 24 MHz
+  {0x012B, 0x00}, // 000 KHz
+
+  {IMX219_TABLE_END, 0x00 }
 };
+
+static struct reg_8 mode_table_clocks[] = {
+  //Clock Settings
+
+  /* CSI data format */
+  {0x018C, 0x0A}, {0x018D, 0x0A},
+
+  // PIXEL CLOCK USED TO DRIVE SENSOR)
+  // VTPXCK_DIV: 4: 1/4, 5: 1/5, 8: 1/8, 10: 1/10
+  {0x0301, 0x05},
+  // VTSYS_DIV = 1: Divide by 1
+  {0x0303, 0x01},
+
+  // PREPLLCK_VT_DIV: 1: 1/1, 2: 1/2, 3: 1/3
+  {0x0304, 0x03}, //MUST BE 3 FOR 24MHz
+
+  // PREPLLCK_OP_DIV: 1: 1/1, 2: 1/2, 3: 1/3
+  {0x0305, 0x03}, //MUST BE 3 FOR 24MHz
+
+  // PLL_VT_MPY = 57 (Multiplier)
+  {0x0306, 0x00}, {0x0307, 0x39},
+  //{0x0306, 0x00}, {0x0307, 0x2E},
+  //{0x0306, 0x00}, {0x0307, 0x57},
+
+  // OPPXCK_DIV (pixel bit depth): 8:1/8 10:1/10
+  {0x0309, 0x0A},
+  // OPSYSCK_DIV (divide by two for double data rate): 1:1/2
+  {0x030B, 0x01},
+
+  // PLL_OP_MPY = 114 (Multiplier)
+  {0x030C, 0x00}, {0x030D, 0x72},
+  //{0x030C, 0x00}, {0x030D, 0x5C},
+  //{0x030C, 0x00}, {0x030D, 0x5A},
+
+
+  //Sensor Pixel Clock: EXCLK_FREQ / PREPLLLCK_VT_DIV * PLL_VT_MPY / VTPXCK_DIV: 24MHz / 3 * 57 / 5 = 91 MHz
+
+  // CIS tunning
+  {0x455E, 0x00},
+  {0x471E, 0x4B},
+  {0x4767, 0x0F},
+  {0x4750, 0x14},
+  {0x4540, 0x00},
+  {0x47B4, 0x14},
+  {0x4713, 0x30},
+  {0x478B, 0x10},
+  {0x478F, 0x10},
+  {0x4793, 0x10},
+  {0x4797, 0x0E},
+  {0x479B, 0x0E},
+
+  {IMX219_TABLE_END, 0x00 }
+};
+
+typedef struct {
+  uint8_t gain;
+  uint16_t coarse_time;
+  uint16_t frame_length;
+}imx219_mode_values_t;
+
+static imx219_mode_values_t mode_1920x1080_values = {
+  .gain = 0,
+  .coarse_time = (1766 - 4),
+  .frame_length=1766,
+};
+
+static imx219_mode_values_t mode_1280x720_values = {
+  .gain = 0,
+  .coarse_time = (851 - 4),
+  .frame_length = 851,
+};
+
 enum {
-	IMX219_MODE_3280x2464,
-	IMX219_MODE_3280x2460,
-	IMX219_MODE_3280x1846,
-	IMX219_MODE_1280x720,
+  IMX219_MODE_1920X1080 = 0,
+  IMX219_MODE_1280X720,
+
+  IMX219_MODE_COMMON,
+  IMX219_MODE_CLOCK,
+  IMX219_MODE_START_STREAM,
+  IMX219_MODE_STOP_STREAM,
+  IMX219_MODE_TEST_PATTERN,
+};
+
+imx219_mode_values_t *mode_values[] = {
+  [IMX219_MODE_1920X1080]     = &mode_1920x1080_values,
+  [IMX219_MODE_1280X720]      = &mode_1280x720_values,
 };
 
-static struct reg_8 *mode_table[] = {
-	[IMX219_MODE_3280x2464] = mode_3280x2464,
-	[IMX219_MODE_3280x2460] = mode_3280x2460,
-	[IMX219_MODE_3280x1846] = mode_3280x1846,
-	[IMX219_MODE_1280x720]  = mode_1280x720,
+static const struct reg_8 *mode_table[] = {
+  [IMX219_MODE_1920X1080]     = mode_1920x1080,
+  [IMX219_MODE_1280X720]      = mode_1280x720,
+
+  [IMX219_MODE_COMMON]        = mode_table_common,
+  [IMX219_MODE_CLOCK]         = mode_table_clocks,
+  [IMX219_MODE_START_STREAM]  = imx219_start,
+  [IMX219_MODE_STOP_STREAM]   = imx219_stop,
 };
 
-static const int imx219_21fps[] = {
-	20,
+static const int imx219_30fps[] = {
+  30,
 };
 
+/*
+camera_common_frmfmt: {struct v4l2_frmsize_discrete size}, {const int *framerates}, {num_framerates}, {hdr_en}, {int  mode}
+*/
+
 static const struct camera_common_frmfmt imx219_frmfmt[] = {
-	{{3280, 2464},	imx219_21fps, 1, 0, IMX219_MODE_3280x2464},
-	{{3280, 2460},	imx219_21fps, 1, 0, IMX219_MODE_3280x2460},
-	{{3280, 1846},	imx219_21fps, 1, 0, IMX219_MODE_3280x1846},
-	{{1280, 720},	NULL, 0, 0, IMX219_MODE_1280x720},
+// Frame Size,    Framerates??,   Num Framerates, HDR Enable,  Mode
+  {{1920,1080},   imx219_30fps,   1,              0,           IMX219_MODE_1920X1080     },
+  {{1280,720},    imx219_30fps,   1,              0,           IMX219_MODE_1280X720      },
 };
 
-#endif
+#endif  /* __IMX219_I2C_TABLES__ */
diff --git a/drivers/media/i2c/j20.c b/drivers/media/i2c/j20.c
new file mode 100644
index 0000000..ebca46a
--- /dev/null
+++ b/drivers/media/i2c/j20.c
@@ -0,0 +1,109 @@
+/*
+ * j20.c - J20 board driver
+ *
+ * Copyright (c) 2015-2016, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+
+#include <linux/seq_file.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+
+#include <linux/i2c-dev.h>
+#include <linux/fs.h>
+
+#include <media/camera_common.h>
+#include <media/soc_camera.h>
+#include <dt-bindings/gpio/tegra-gpio.h>
+
+static struct of_device_id j20_of_match[] = {
+	{ .compatible = "nvidia,j20", },
+	{ },
+};
+
+MODULE_DEVICE_TABLE(of, j20_of_match);
+
+static int j20_probe(struct i2c_client *client,
+		     const struct i2c_device_id *id)
+{
+  struct device_node *np = client->dev.of_node;
+  const struct of_device_id *match;
+  int gpio;
+
+  dev_info(&client->dev, "[J20] Driver: Function: %s.\n", __func__);
+
+  match = of_match_device(j20_of_match, &client->dev);
+  if (!match) {
+    dev_info(&client->dev, "Failed to find matching dt id\n");
+    return -1;
+  }
+
+  gpio = of_get_named_gpio(np, "reset-gpios", 0);
+  if (gpio < 0) {
+    dev_err(&client->dev, "reset gpios not in DT\n");
+  }
+
+  gpio_set_value(gpio, 1);
+
+  dev_info(&client->dev,"[J20]: Enabling GPIO: %i.\n", gpio);
+
+  if (i2c_smbus_write_byte_data(client, 6, 0x3e) < 0)
+    dev_err(&client->dev, "Failed writing to reg: %d val %d\n", 6, 0x3e);
+  if (i2c_smbus_write_byte_data(client, 7, 0x33) < 0)
+    dev_err(&client->dev, "Failed writing to reg: %d val %d\n", 7, 0x33);
+  if (i2c_smbus_write_byte_data(client, 2, 0xfe) < 0)
+    dev_err(&client->dev, "Failed writing to reg: %d val %d\n", 2, 0xfe);
+  if (i2c_smbus_write_byte_data(client, 3, 0xff) < 0)
+    dev_err(&client->dev, "Failed writing to reg: %d val %d\n", 3, 0xff);
+
+  dev_info(&client->dev,"[J20]: Writing setup configuration .\n");
+
+  return 0;
+}
+
+static int
+j20_remove(struct i2c_client *client)
+{
+  return 0;
+}
+
+static const struct i2c_device_id j20_id[] = {
+  { "j20", 0 },
+  { }
+};
+
+MODULE_DEVICE_TABLE(i2c, j20_id);
+
+static struct i2c_driver j20_i2c_driver = {
+  .driver = {
+    .name = "j20",
+    .owner = THIS_MODULE,
+    .of_match_table = of_match_ptr(j20_of_match),
+  },
+  .probe = j20_probe,
+  .remove = j20_remove,
+  .id_table = j20_id,
+};
+
+module_i2c_driver(j20_i2c_driver);
+
+MODULE_DESCRIPTION("Driver for J20 setup");
+MODULE_AUTHOR("<support@ridgerun.com>");
+MODULE_LICENSE("GPL v2");
-- 
2.7.4

